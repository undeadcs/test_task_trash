
Правила обработки данных

Правила входных данных:
для массива ожидается массив только с целочисленными индексами (vector)
для структуры ожидается массив только со строковыми индексами (map, hash_map)
если тип входных данных не совпадает с ожидаемым, то возвращать null

Правила вложенности:
если ожидается массив и входные массив, то возвращается массив
если во входном массиве есть хоть один не валидный элемент, то возвращать пустой массив
если во входящем ассоциативном массиве имеется поле и оно валидно, то оно попадает в исходящие данные
если во входящих данных значение поля структуры не валидно, то оно не попадает в исходящие данные (форма валидна, содержание нет)


PHP
Варианты реализации:

1. Для спецификации класс, с атрибутами на поля. Класс для обработки входящих данных использует рефлексию.
   Добавление новых типов: добавление атрибутов и их обработка

   входящие данные:
   Input - интерфейс
       ValueExists( string $name )
       GetValue( string $name )
   HttpRequest - данные из запроса
   JsonObject - объект, декодированный из json

   пример спецификации:
   class Values {
       public int $foo;
       public string $bar;
       #[PhoneNumber]
       public string $baz;
       public string $optionalValue = 'not-required';
       public array $mixedValues;
       #[AllowedTypes(PhoneNumber::class)]
       public array $phones;
   }

   атрибуты:
   Alias - список альтернативных имен поля
   Unsigned - применимо к int, float
   Optional - параметр не обязателен во входящих данных
   Minimum, Maximum - ограничения по значениям, для int, float это числа, для date,datetime - даты
   AllowedTypes - список допустимых типов в массиве (по умолчанию в массиве допустимы все известные типы)

   Обработчик типа
   TypeHandler
       Validate( value ) - проверка входящего значения на валидность
       Filter( value, attribues ) - фильтрация входящего значения для присвоения полю объекта
       SupportedAttributes - имена классов-атрибутов, которые допускаются для полей данного типа
   StringHandler

   [-] нет явного указания типа корневого элемента

[FAILED] {
	при добавлении вложенности оказалось, что придется городить специфические атрибуты и классы обработки типов, а также проверки в самом парсере
	невозможно задать тип корневого элемента, из-за чего не удастся получать массив или просто строку
	если делать конвертер спецификации из какого-то хитрого формата, то придется генерировать классы с атрибутами и тп.
}

2. Для спецификации массив и константы. Класс для обработки входящих данных использует массив.
   Добавление новых типов: добавление констант и их обработка

   пример спецификации:
   [ 'foo', 'bar', [ 'indexInput' => 'baz', 'type' => 'phone' ] ]

   [-] нет явного указания типа корневого элемента

[FAILED] {
	при добавлении вложенности массив массивов получился черезчур замутный код
	невозможно задать тип корневого элемента, из-за чего не удастся получать массив или просто строку
}

3. Для спецификации используется отдельный класс. (следовательно можно указать тип корневого элемента)
   Система типов остается в виде обработчиков (валидатор+фильтр в едином классе).
   дополнительно можно будет добавить поле кастомного обработчика значения (например, исключительное поле, которому зарегистрированный обработчик не подходит)

   [-] для валидации массива нагорожен огород
   [-] поля структуры неудобно задаются
   [-] по ошибке можно для скаляра внезапно задать тип (у скаляра не может быть вложенности)

4. Для спецификации используется отдельный класс. Объект спецификации и есть обработчик типа (валидация+фильтрация)
   В этой схеме парсер не нужен как таковой, весь функционал переносится в типы (функция фильтрации по сути и возвращает результат, а система типов обеспечивает вложенность)
   Спецификации скаляров и массивов отделены в корневом классе (массивы и структуры - это контейнерный тип данных).

